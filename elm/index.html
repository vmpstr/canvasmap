<!doctype html>
<head>
  <link rel=stylesheet href='styles/styles.css'></link>
  <link rel=stylesheet href='styles/scroller-styles.css'></link>
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <meta charset="utf-8">
</head>

<body>
  <div id="map"></div>
</body>


<script src="map.js"></script>
<script src="child-area.js"></script>
<script src="node-label.js"></script>
<script>
let app = undefined;

let lastX = 0;
let lastY = 0;
let id = "";
let dragging = false;
let blockInput = false;
function onPointerDown(e) {
  document.body.addEventListener("pointermove", onPointerMove);
  document.body.addEventListener("pointerup", onPointerUp);
  lastX = e.x;
  lastY = e.y;
  id = e.targetId;
}

function onPointerMove(e) {
  e.preventDefault();
  if (blockInput)
    return;

  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;

  if (!dragging) {
    const d2 = dx * dx + dy * dy;
    dragging = d2 >= 100;
    if (dragging) {
      lastX = e.clientX;
      lastY = e.clientY;

      const target_rect = document.getElementById(id).getBoundingClientRect();
      app.ports.portOnDragStart.send({
        targetId: id,
        geometry: {
          target: {
            position: { x: target_rect.x, y: target_rect.y },
            size: { x: target_rect.width, y: target_rect.height }
          }
        }
      });
    }
    return;
  }
  lastX = e.clientX;
  lastY = e.clientY;

  const target_rect = document.getElementById(id).getBoundingClientRect();
  app.ports.portOnDragBy.send({
    targetId: id,
    dx: dx,
    dy: dy,
    geometry: {
      target: {
        position: { x: target_rect.x, y: target_rect.y },
        size: { x: target_rect.width, y: target_rect.height }
      },
      beacons: getBeacons()
    }
  });
}

function getBeacons() {
  let result = []
  Array.from(document.getElementsByClassName("beacon")).forEach((e) => {
    const rect = e.getBoundingClientRect();
    result.push({
      path: e.getAttribute("path"),
      location: { x: rect.x, y: rect.y }
    });
  });
  return result;
}

function onPointerUp(e) {
  e.preventDefault();

  dragging = false;
  document.body.removeEventListener("pointermove", onPointerMove);
  document.body.removeEventListener("pointerup", onPointerUp);

  app.ports.portOnDragStop.send();
}

function onRafAlignRequest() {
  blockInput = true;
  requestAnimationFrame(() => {
    blockInput = false;
    // setTimeout for processing accumulated input?
  });
}

function onEditLabel(e) {
  // raf since we could be just attaching the node.
  requestAnimationFrame(() => {
    document.getElementById(e.targetId).querySelector("node-label").edit();
  });
}

const kStateVersion = "3"
function saveState(nodes) {
  localStorage.setItem("mm-version", kStateVersion);
  localStorage.setItem("mm-nodes", JSON.stringify(nodes));
}

function loadState() {
  const version = localStorage.getItem("mm-version");
  if (!version || version !== kStateVersion) {
    app.ports.portOnLoadState.send([]);
    return;
  }
  const nodes = JSON.parse(localStorage.getItem("mm-nodes"));
  app.ports.portOnLoadState.send(nodes);
}

let ewData = undefined;
function onEwResizePointerDown(e) {
  document.body.addEventListener("pointermove", onEwResizePointerMove);
  document.body.addEventListener("pointerup", onEwResizePointerUp);
  const target = document.getElementById(e.targetId);
  const rect = target.getBoundingClientRect();

  const style = target.getAttribute("style");
  target.setAttribute("style", "");
  const unboundRect = target.getBoundingClientRect();
  target.setAttribute("style", style);

  ewData = {
    targetId: e.targetId,
    lastX: e.x,
    lastWidth: rect.width,
    unboundWidth: unboundRect.width
  };
}

function onEwResizePointerMove(e) {
  e.preventDefault();
  if (blockInput)
    return;

  dx = e.clientX - ewData.lastX;
  ewData.lastX = e.clientX;

  const newWidth = ewData.lastWidth + dx;
  ewData.lastWidth = newWidth;
  if (newWidth >= ewData.unboundWidth) {
    app.ports.portOnMaxWidthChanged.send({
      targetId: ewData.targetId
    });
  } else {
    app.ports.portOnMaxWidthChanged.send({
      targetId: ewData.targetId,
      maxWidth: Math.max(0, newWidth)
    });
  }
}

function onEwResizePointerUp(e) {
  e.preventDefault();
  document.body.removeEventListener("pointermove", onEwResizePointerMove);
  document.body.removeEventListener("pointerup", onEwResizePointerUp);
  ewData = undefined;
}

onload = () => {
  app = Elm.Map.init({ node: document.getElementById("map") });
  app.ports.portOnPointerDown.subscribe(onPointerDown);
  app.ports.portRafAlign.subscribe(onRafAlignRequest);
  app.ports.portEditLabel.subscribe(onEditLabel);
  app.ports.portSaveState.subscribe(saveState);
  app.ports.portLoadState.subscribe(loadState);
  app.ports.portOnEwResizePointerDown.subscribe(onEwResizePointerDown);
  document.addEventListener("keydown", (e) => {
    // TODO: Maybe filter based on what is handled?
    e.preventDefault();
    app.ports.portOnKeyDown.send({ code: e.code });
  })
};
</script>

